<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fix.py - Project Integrity and Schema Validator</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0 auto;
            max-width: 900px;
            padding: 2em;
            color: #333;
        }
        h1, h2, h3 {
            font-weight: 600;
            color: #222;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: #f6f8fa;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 3px;
        }
        pre {
            background-color: #f6f8fa;
            padding: 16px;
            overflow: auto;
            border-radius: 5px;
            font-size: 85%;
        }
        pre code {
            padding: 0;
            margin: 0;
            font-size: 100%;
            background-color: transparent;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin-bottom: 0.5em;
        }
    </style>
</head>
<body>

    <h1><code>fix.py</code> - Project Integrity and Schema Validator</h1>
    <p>This script is a standalone diagnostic tool designed to perform a "health check" on the project. It verifies the integrity of the file structure and validates the schemas of core databases against a predefined contract. The results are saved both to a JSON file and to the administrative database for later review.</p>

    <h2>1. Configuration</h2>
    <p>The script's behavior is driven by a set of configuration lists and dictionaries that define the expected state of a healthy project.</p>
    <pre><code>EXPECTED_DIRS = [...]
EXPECTED_FILES = [...]
EXPECTED_SCHEMAS = {...}</code></pre>
    <ul>
        <li><code>EXPECTED_DIRS</code>: A list of directory paths that must exist for the application to function correctly.</li>
        <li><code>EXPECTED_FILES</code>: A list of essential file paths, including the main application, SQL schemas, and key frontend assets.</li>
        <li><code>EXPECTED_SCHEMAS</code>: A nested dictionary that acts as the "source of truth" for database structures. It defines the expected tables, columns, data types, and NOT NULL constraints for the primary databases. This allows for precise, automated schema validation.</li>
    </ul>

    <h2>2. Core Functions</h2>
    <p>The script's logic is broken down into several modular functions for clarity and reusability.</p>

    <h3><code>get_db_connection(db_path)</code></h3>
    <ul>
        <li><strong>Purpose</strong>: To establish a connection to a SQLite database in a safe manner.</li>
        <li><strong>Mechanism</strong>: It wraps the <code>sqlite3.connect()</code> call in a <code>try...except</code> block.</li>
        <li><strong>Output</strong>: Returns a <code>sqlite3.Connection</code> object on success or a formatted error string on failure. This allows calling functions to easily check if the connection was successful by using <code>isinstance(conn, str)</code>.</li>
    </ul>

    <h3><code>check_structure(results)</code></h3>
    <ul>
        <li><strong>Purpose</strong>: To verify that all expected directories and files are present in the project.</li>
        <li><strong>Mechanism</strong>: It iterates through the <code>EXPECTED_DIRS</code> and <code>EXPECTED_FILES</code> lists, using <code>os.path.isdir()</code> and <code>os.path.isfile()</code> respectively to check for the existence of each item.</li>
        <li><strong>Output</strong>: It populates the <code>results["structure"]</code> dictionary with its findings, marking each file and directory with a status of "OK" or "MISSING".</li>
    </ul>

    <h3><code>check_schemas(results)</code></h3>
    <ul>
        <li><strong>Purpose</strong>: To perform a deep validation of the database schemas against the <code>EXPECTED_SCHEMAS</code> configuration.</li>
        <li><strong>Mechanism</strong>: This is the most complex check. For each database:
            <ol>
                <li>It first checks if the <code>.db</code> file exists.</li>
                <li>It uses the SQLite <code>PRAGMA table_info(table_name)</code> command to introspect the database and retrieve the actual schema of each table.</li>
                <li>It compares the actual column names, data types, and NOT NULL constraints with the expected values defined in the configuration.</li>
            </ol>
        </li>
        <li><strong>Output</strong>: It populates the <code>results["schemas"]</code> list with a detailed report for each database. If any discrepancies are found, the database's status is marked as "ERROR" and the specific column mismatches are noted.</li>
    </ul>

    <h3><code>save_report_to_db(report)</code></h3>
    <ul>
        <li><strong>Purpose</strong>: To persist the generated diagnostic report into the administrative database for historical tracking and review.</li>
        <li><strong>Mechanism</strong>: It connects to the <code>admin.db</code>, ensures the <code>FIX_REPORTS</code> table exists by re-running the schema, converts the entire report dictionary to a JSON string using <code>json.dumps()</code>, and inserts it into the table along with a timestamp.</li>
        <li><strong>Output</strong>: Prints a confirmation or error message to the console. This provides a durable log of health checks over time.</li>
    </ul>

    <h3><code>main()</code></h3>
    <ul>
        <li><strong>Purpose</strong>: The main entry point that orchestrates the entire diagnostic process.</li>
        <li><strong>Execution Flow</strong>:
            <ol>
                <li>Initializes a results dictionary with a timestamp.</li>
                <li>Calls <code>check_structure()</code> and <code>check_schemas()</code> to run the diagnostics and populate the results.</li>
                <li>Ensures the <code>logs/</code> directory exists.</li>
                <li>Saves the complete results dictionary to a timestamped JSON file in the <code>logs/</code> directory for easy file-based access.</li>
                <li>Calls <code>save_report_to_db()</code> to also save the same report to the database, providing dual-method access to the report.</li>
            </ol>
        </li>
    </ul>

    <h2>3. Script Execution</h2>
    <p>The standard <code>if __name__ == "__main__":</code> block ensures that the <code>main()</code> function is called only when the script is executed directly from the command line (e.g., <code>python fix.py</code>). This makes the script a runnable utility while allowing its functions to be potentially imported by other modules (like <code>app_debug.py</code>) without side effects.</p>

</body>
</html>